# Техническое описание многоагентной системы распределения задач

## 1. Архитектура системы

### 1.1 Определение задачи

**Задача** в нашей системе представляет собой запрос к языковой модели (LLM), который содержит:

```python
class Task:
    def __init__(self, prompt: str, priority: int, complexity: int):
        self.prompt = prompt          # Текст запроса к LLM
        self.priority = priority      # Приоритет (1-10) 
        self.complexity = complexity  # Сложность (1-10)
        self.type = self._determine_task_type()  # Автоматически определяемый тип
```

**Известные параметры задачи при поступлении:**
- `prompt` - текстовое описание задачи
- `priority` - приоритет выполнения (1=низкий, 10=высокий)
- `complexity` - сложность задачи (1=простая, 10=сложная)
- `features` - 5-мерный вектор характеристик: `[x₁, x₂, x₃, x₄, x₅]`

**Автоматически определяемые параметры:**
- `type` - тип задачи (см. раздел 1.2)
- `confidence` - уверенность классификации (0-1)

### 1.2 Классификация типов задач

Система автоматически классифицирует каждую задачу в один из 9 типов:

1. **`math`** (вес: 1.2) - Математические вычисления
   - *Описание*: Задачи с формулами, уравнениями, интегралами, производными
   - *Ключевые слова*: уравнение, вычислить, интеграл, производная, матрица
   - *Примеры*: "Решить x² + 5x + 6 = 0", "Найти производную f(x) = x³"

2. **`code`** (вес: 1.1) - Программирование
   - *Описание*: Написание, отладка, рефакторинг кода
   - *Ключевые слова*: python, код, функция, алгоритм, отладка, API
   - *Примеры*: "Написать функцию сортировки", "Отладить код с ошибкой"

3. **`text`** (вес: 1.0) - Текстовые задачи
   - *Описание*: Написание статей, перевод, редактирование
   - *Ключевые слова*: текст, статья, перевод, грамматика, эссе
   - *Примеры*: "Написать статью об ИИ", "Проверить грамматику"

4. **`analysis`** (вес: 1.0) - Анализ данных
   - *Описание*: Исследование, аналитика, извлечение выводов
   - *Ключевые слова*: анализ, данные, исследование, тренды, корреляция
   - *Примеры*: "Проанализировать продажи", "Найти корреляцию"

5. **`creative`** (вес: 0.9) - Творческие задачи
   - *Описание*: Генерация идей, дизайн, концепции
   - *Ключевые слова*: креативность, дизайн, идеи, логотип, слоган
   - *Примеры*: "Создать логотип", "Придумать слоган"

6. **`explanation`** (вес: 0.8) - Объяснения
   - *Описание*: Разъяснение сложных понятий
   - *Ключевые слова*: объяснить, что такое, как работает, принцип
   - *Примеры*: "Объяснить блокчейн", "Как работает ИИ?"

7. **`planning`** (вес: 1.0) - Планирование
   - *Описание*: Составление планов и стратегий
   - *Ключевые слова*: план, этапы, roadmap, организовать
   - *Примеры*: "Составить план проекта", "Спланировать кампанию"

8. **`research`** (вес: 0.9) - Исследования
   - *Описание*: Поиск информации, изучение источников
   - *Ключевые слова*: найти информацию, изучить, источники
   - *Примеры*: "Найти тренды в ИИ", "Изучить литературу"

9. **`optimization`** (вес: 1.1) - Оптимизация
   - *Описание*: Улучшение процессов и производительности
   - *Ключевые слова*: оптимизация, улучшить, эффективность
   - *Примеры*: "Оптимизировать код", "Улучшить производительность"

**Алгоритм классификации:**
```python
final_score = (keyword_score * 0.7 + cosine_score * 0.25 + pattern_score * 0.05) * type_weight
```

### 1.3 Формирование пакетов задач

**Мотивация пакетной обработки:**
- **Эффективность**: Снижение накладных расходов на обработку отдельных задач
- **Балансировка нагрузки**: Более точное распределение нагрузки между брокерами
- **Оптимизация ресурсов**: Лучшее использование пропускной способности исполнителей
- **Снижение латентности**: Уменьшение времени ожидания для групп связанных задач

**Формирование пакетов:**
```python
def generate_batch(min_size=1, max_size=6) -> List[Dict]:
    batch_size = random.randint(min_size, max_size)
    batch = random.sample(available_tasks, batch_size)
    return batch
```

**Пакет содержит:**
- 1-6 задач (случайный размер)
- Задачи могут быть разных типов
- Каждая задача сохраняет свои индивидуальные параметры

### 1.4 Онлайн/реал-тайм система

Система работает в режиме реального времени:
- **Поступление задач**: Задачи поступают асинхронно
- **Немедленная обработка**: Каждый пакет обрабатывается сразу при поступлении
- **Адаптивное обучение**: Параметры θ обновляются онлайн после каждых 10 задач
- **Динамическая балансировка**: Граф связности обновляется периодически

## 2. Компоненты системы

### 2.1 Брокеры (Контроллеры)

**Брокер** - центральный компонент для распределения задач:

```python
class Broker:
    def __init__(self, id, graph_service):
        self.id = id                    # Уникальный ID брокера
        self.graph_service = graph_service  # Ссылка на граф связности
        self.load = 0                   # Текущая нагрузка
        self.history = []               # История обработанных задач
        self.theta = [random.random() for _ in range(5)]  # Параметры θ
```

**Функции брокера:**
1. **Прием пакетов**: `receive_prompt(prompt_or_batch, all_brokers)`
2. **Предсказание параметров**: Использует модели для получения p̂ и ŵ
3. **Вычисление дедлайна**: `D_i = r_i + ŵ_i + x_i^T θ`
4. **Выбор исполнителя**: `select_executor(prompt)`
5. **Обновление параметров**: SPSA-оптимизация θ

### 2.2 Исполнители (Агенты)

**Исполнитель** - компонент для выполнения задач через LLM API:

```python
class Executor:
    def __init__(self, executor_id, model_name="gpt-3.5-turbo"):
        self.id = executor_id
        self.model_name = model_name
        self.current_load = 0           # Текущая загрузка
        self.max_concurrent = 3         # Максимум одновременных задач
        self.timeout_threshold = 30.0   # Порог таймаута
```

**Характеристики исполнителя:**
- **Загрузка**: Количество одновременно выполняемых задач
- **Доступность**: `availability = 1.0 - (current_load / max_concurrent)`
- **Релевантность**: Соответствие модели типу задачи
- **Производительность**: Время выполнения и успешность

### 2.3 Логика назначения задач

**Алгоритм назначения:**

1. **Выбор брокера** (LVP - Load Vector Protocol):
   ```
   u_i = h * ∑_{j ∈ neighbors[i]} r_ij * (y_i - y_j) - γ * (y_i - mean(y_neighbors))
   ```
   где:
   - `h = 0.1` - коэффициент взаимодействия соседей
   - `γ = 0.05` - коэффициент локального баланса
   - `r_ij` - вес ребра между брокерами i и j
   - `y_i` - текущая нагрузка брокера i

2. **Предсказание параметров**:
   - **Нагрузка**: `p̂ = w^T * features + noise`
   - **Время ожидания**: `ŵ = ∑(features) * 2 + length_factor + noise`

3. **Вычисление дедлайна**:
   ```
   D_i = r_i + ŵ_i + x_i^T θ
   ```
   где:
   - `r_i` - случайный компонент
   - `ŵ_i` - предсказанное время ожидания
   - `x_i^T θ` - персонализированная коррекция

4. **Выбор исполнителя**: Случайный выбор из доступных (упрощенная модель)

### 2.4 Предсказательные модели

**Что предсказываем:**
1. **Нагрузка p̂** - вычислительная сложность задачи (0-1)
2. **Время ожидания ŵ** - ожидаемое время выполнения (секунды)

**Зачем предсказываем:**
- **Балансировка нагрузки**: Распределение задач по загруженности
- **Планирование ресурсов**: Прогнозирование потребности в исполнителях
- **Оптимизация SLA**: Соблюдение временных ограничений
- **Адаптация параметров**: Настройка θ под изменяющиеся условия

**Модели предсказания:**

```python
def predict_load(prompt):
    features = prompt['features']  # 5-мерный вектор
    weights = [0.3, 0.2, 0.25, 0.15, 0.1]
    return max(0, min(1, np.dot(features, weights) + noise))

def predict_waiting_time(prompt):
    features = prompt['features']
    base_time = np.sum(features) * 2
    length_factor = len(prompt['text']) / 1000 * 0.5
    return max(0.1, base_time + length_factor + noise)
```

## 3. Моделирование и эксперименты

### 3.1 Параметры моделирования

**Конфигурация системы:**
- **Брокеры**: 3-5 брокеров в зависимости от эксперимента
- **Исполнители**: 5-8 исполнителей с различными моделями
- **Граф связности**: Случайный граф с плотностью ~0.3
- **Задачи**: 50-100 задач за эксперимент

**Временные параметры:**
- **Время поступления**: Пуассоновский процесс с λ = 2 задачи/минуту
- **Размер пакета**: Равномерное распределение [1, 6]
- **Обновление θ**: Каждые 10 обработанных задач
- **Обновление графа**: Каждые 50 задач

### 3.2 Генерация промптов

**Базовые промпты по типам:**
```python
test_prompts = {
    'math': "Решить квадратное уравнение x^2 + 5x + 6 = 0",
    'code': "Написать функцию сортировки на Python", 
    'text': "Написать статью о влиянии ИИ",
    'analysis': "Проанализировать данные продаж",
    'creative': "Создать дизайн логотипа",
    'explanation': "Объяснить принцип работы нейронных сетей",
    'planning': "Составить план маркетинговой кампании",
    'research': "Найти информацию о трендах в ИИ",
    'optimization': "Оптимизировать производительность системы"
}
```

**Генерация характеристик:**
```python
def generate_features(task_type):
    # Базовые паттерны для каждого типа
    base_patterns = {
        'math': [1.2, 0.8, 0.1, 0.9, 0.3],
        'code': [0.3, 1.5, 0.7, 0.6, 1.1],
        'creative': [0.2, 0.6, 0.9, 1.4, 1.2]
        # ... остальные типы
    }
    
    base = base_patterns.get(task_type, [0.5, 0.5, 0.5, 0.5, 0.5])
    noise = np.random.normal(0, 0.1, 5)
    return np.clip(base + noise, 0, 2)
```

### 3.3 Метрики системы

**Основные метрики:**

1. **Функция потерь для нагрузки:**
   ```
   F_proc(θ) = mean(((p̂ + x^T θ - p_real) / (h(T) * p_real + ε))²)
   ```

2. **Функция потерь для времени ожидания:**
   ```
   F_wait(θ) = mean((ŵ + x^T θ - w_real)² * (1 - s/s_max))
   ```

3. **Комбинированная функция потерь:**
   ```
   F_combined(θ) = F_proc(θ) + F_wait(θ)
   ```

4. **Метрика балансировки нагрузки:**
   ```
   Load_Balance = 1 - std(broker_loads) / mean(broker_loads)
   ```

5. **Успешность выполнения:**
   ```
   Success_Rate = completed_tasks / total_tasks
   ```

## 4. Пояснения к графикам

### 4.1 Приоритет задач

**Определение приоритета:**
- **Источник**: Задается пользователем при создании задачи
- **Диапазон**: 1-10 (1 = низкий, 10 = критический)
- **Влияние**: Влияет на порядок обработки в очереди брокера
- **Распределение в эксперименте**: Равномерное от 3 до 9

### 4.2 Временные метки (даты)

**Происхождение дат:**
- **Система времени**: Используется `datetime.now()` при обработке каждой задачи
- **Формат**: ISO 8601 (2025-07-20T10:30:45Z)
- **Назначение**: Отслеживание последовательности обработки и расчет метрик времени
- **Точность**: Миллисекунды для высокоточного измерения производительности

```python
execution_record = {
    'timestamp': datetime.now(),
    'start_time': start_time,
    'end_time': end_time,
    'duration': (end_time - start_time).total_seconds()
}
```

### 4.3 Успешность выполнения задач

**Определение успешности:**
```python
def calculate_success():
    # Базовая вероятность успеха: 90%
    base_success_rate = 0.9
    
    # Факторы влияния:
    complexity_penalty = task.complexity * 0.01  # Сложные задачи чаще падают
    load_penalty = executor.current_load * 0.02   # Перегруженные исполнители менее надежны
    timeout_risk = 1.0 if execution_time > threshold else 0.0
    
    final_success_rate = base_success_rate - complexity_penalty - load_penalty - timeout_risk
    return random.random() < final_success_rate
```

**Критерии неуспеха:**
- Превышение таймаута (30 секунд)
- Ошибки модели (IndexError, API errors)
- Перегрузка исполнителя
- Случайные сбои (моделируют реальные условия)

### 4.4 Производительность агентов

**Метрики производительности исполнителя:**

1. **Утилизация (Utilization):**
   ```
   Utilization = current_load / max_concurrent_tasks
   ```

2. **Пропускная способность (Throughput):**
   ```
   Throughput = completed_tasks / total_time
   ```

3. **Средняя латентность:**
   ```
   Avg_Latency = sum(execution_times) / completed_tasks
   ```

4. **Коэффициент успешности:**
   ```
   Success_Rate = successful_tasks / total_assigned_tasks
   ```

5. **Эффективность по типам задач:**
   ```
   Type_Efficiency[task_type] = success_rate[task_type] / avg_time[task_type]
   ```

**Релевантность исполнителя к типу задачи:**
```python
relevance_map = {
    'math': 0.9 if 'math' in model_name else 0.6,
    'code': 0.9 if 'code' in model_name else 0.7,
    'text': 0.8,  # Все модели хорошо работают с текстом
    'analysis': 0.7,
    'creative': 0.6,
    'general': 0.5
}
```

### 4.5 Динамика параметров θ

**Эволюция параметров SPSA:**
- **Начальные значения**: Случайные из [0, 1]
- **Обновление**: Каждые 10 задач по алгоритму SPSA
- **Консенсус**: Учет параметров соседних брокеров
- **Сходимость**: Постепенная адаптация к оптимальным значениям

**Формула обновления:**
```
θ_{i,new} = θ_{i,old} - α * (ĝ + γ * ∑_{j∈neighbors} b_ij * (θ_j - θ_i))
```

где:
- `α = 0.01` - скорость обучения
- `γ = 0.02` - коэффициент консенсуса
- `ĝ` - приближенный градиент SPSA
- `b_ij` - веса ребер графа

Данная система реализует полноценный пайплайн обработки задач с адаптивным обучением, балансировкой нагрузки и консенсусной оптимизацией параметров в реальном времени.
