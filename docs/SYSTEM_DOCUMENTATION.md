# Документация многоагентной системы распределения задач

## Оглавление
1. [Архитектура системы](#архитектура-системы)
2. [Описание моделирования](#описание-моделирования)
3. [Объяснение ключевых графиков](#объяснение-ключевых-графиков)

## Архитектура системы

### Общее описание задачи
Система представляет собой многоагентную архитектуру для онлайн-распределения вычислительных задач между исполнителями через брокеров, работающую в реальном времени с консенсусным обучением и оптимизацией предсказаний.

### Основные компоненты

#### 1. Задачи (Tasks)
**Описание**: Единичная работа, которую необходимо выполнить в системе.

**Структура задачи**:
- `id` - уникальный идентификатор
- `prompt` - текстовое описание задачи
- `priority` - приоритет от 1 до 10 (где 10 - максимальный)
- `complexity` - сложность от 1 до 10
- `features` - вектор признаков размерности 10 для ML-предсказаний
- `type` - тип задачи (автоматически определяется)

**Типы задач** (из `TASK_TYPES`):

| Тип | Описание | Ключевые слова |
|-----|----------|----------------|
| `math` | Математические вычисления | calculate, solve, equation, formula |
| `code` | Программирование и отладка | write, debug, function, algorithm |
| `text` | Написание и редактирование | write, create, compose, draft |
| `analysis` | Анализ данных и статистика | analyze, compare, evaluate, statistics |
| `creative` | Творческие задания | design, brainstorm, creative, imagine |
| `explanation` | Объяснения и описания | explain, describe, what is, how does |
| `planning` | Планирование и стратегия | plan, strategy, organize, schedule |
| `research` | Исследования и поиск | research, find, investigate, survey |
| `optimization` | Оптимизация процессов | optimize, improve, enhance, efficiency |

#### 2. Пакеты (Batches)
**Описание**: Группы задач (от 1 до 6), объединяемые для одновременной обработки. Формируются динамически для имитации реального онлайн-потока заданий.

#### 3. Брокеры (Brokers)
**Описание**: Контроллеры для управления распределением задач между исполнителями.

**Основные функции**:
- Получение и обработка пакетов задач (`receive_prompt`)
- Предсказание нагрузки и времени ожидания
- Вычисление дедлайнов по формуле: `D_i = r_i + ŵ_i + x_i^T θ`
- Выбор исполнителей через LVP (Local Voting Protocol)
- Обновление параметров через SPSA оптимизацию
- Консенсусное обучение с соседними брокерами

**Параметры брокера**:
- `theta` - вектор параметров размерности 5 для предсказаний
- `load` - текущая нагрузка
- `history` - история обработанных задач

#### 4. Исполнители (Executors)
**Описание**: Агенты, фактически выполняющие задачи через LLM API.

**Характеристики**:
- `max_concurrent_tasks`: 3 одновременные задачи
- `timeout_threshold`: 30 секунд
- `cost_per_token`: $0.001 за токен
- Поддержка как реальных API, так и мок-версий для тестирования

**Ключевые метрики**:
- Доступность (`get_availability`)
- Релевантность задач (`calculate_relevance`)
- Риск таймаута (`_calculate_timeout_risk`)
- Утилизация ресурсов

#### 5. Граф связности
**Описание**: Граф взаимодействий между брокерами для консенсусного обучения.

**Параметры**:
- Вероятность создания ребра: 0.3
- Минимум соседей: 2, максимум: 5
- Затухание весов со временем: 0.95

### Алгоритмы и протоколы

#### LVP (Local Voting Protocol)
Протокол распределения нагрузки между брокерами:

```
u_i = h * ∑_{j ∈ neighbors[i]} r_ij * (y_i - y_j) - γ * (y_i - mean(y_neighbors))
```

где:
- `h = 0.1` - коэффициент взаимодействия соседей
- `γ = 0.05` - коэффициент локального баланса
- `r_ij` - вес ребра между брокерами i и j
- `y_i` - текущая нагрузка брокера i

#### SPSA (Simultaneous Perturbation Stochastic Approximation)
Алгоритм обновления параметров θ:

1. Генерация возмущения: `Δ ∈ {-1, +1}^d`
2. Создание возмущенных параметров: `θ⁺ = θ + βΔ`, `θ⁻ = θ - βΔ`
3. Вычисление функций потерь: `F_proc(θ)` и `F_wait(θ)`
4. Приближенный градиент: `ĝ = (F(θ⁺) - F(θ⁻)) / (2β) * Δ`
5. Обновление: `θ ← θ - α * ĝ`

**Параметры SPSA**:
- `α = 0.01` - скорость обучения
- `β = 0.1` - размер возмущения
- Частота обновления: каждые 10 задач

### Функции потерь

#### Функция потерь для обработки задач
```
F_proc(θ) = mean(((p̂ + x^T θ - p_real) / (h(T) * p_real + ε))²)
```

#### Функция потерь для времени ожидания
```
F_wait(θ) = mean((ŵ + x^T θ - w_real)² * (1 - s/s_max))
```

где:
- `p̂` - предсказанная нагрузка
- `ŵ` - предсказанное время ожидания
- `s` - коэффициент успешности
- `h(T) = 0.1` - коэффициент нормализации
- `ε = 1e-6` - регуляризация

## Описание моделирования

### Используемые модели

#### 1. Предсказание нагрузки (LoadPredictor)
- **Простая модель**: взвешенная сумма характеристик + шум
- **Обучаемая модель**: нейронная сеть с градиентным обучением
- **Входы**: priority, complexity, features
- **Выход**: предсказанная вычислительная нагрузка

#### 2. Предсказание времени ожидания (WaitingTimePredictor)
- **Архитектура**: аналогична LoadPredictor
- **Цель**: предсказание времени до начала выполнения задачи

### Параметры моделирования

#### Количество агентов
- **Брокеры**: 3-6 (из `SYSTEM_PARAMS['num_brokers']`)
- **Исполнители**: 5-8 (из `SYSTEM_PARAMS['num_executors']`)

#### Генерация задач
- **Шаблоны промптов**: 50+ предопределенных задач разных типов
- **Распределение по типам**: math, programming, explanation, creative, factual, analysis
- **Размер пакетов**: 1-6 задач
- **Приоритеты**: равномерное распределение 1-10
- **Сложность**: нормальное распределение со средним 5

#### Временные характеристики
- **Время выполнения**: 1-10 секунд (базовое)
- **Модификация по сложности**: `base_time * complexity * 0.5`
- **Вариация**: ±30% от базового времени
- **Генерация токенов**: 50-500 токенов

### Ключевые метрики и формулы

#### 1. Успешность выполнения
```
SuccessRate = (количество успешных задач / общее количество задач) × 100%
```

#### 2. Средняя ошибка предсказания
```
МeanError = (1/N) * Σ|predicted_i - actual_i|
```

#### 3. Утилизация ресурсов
```
Utilization = current_load / max_capacity
```

#### 4. Корреляция предсказаний
```
r = Σ((xi - x̄)(yi - ȳ)) / sqrt(Σ(xi - x̄)² * Σ(yi - ȳ)²)
```

#### 5. Стоимость выполнения
```
Cost = tokens_generated × cost_per_token
```

#### 6. Риск таймаута
```
TimeoutRisk = {
  1.0,  если execution_time > threshold
  0.7,  если execution_time > 0.8 * threshold  
  0.3,  если execution_time > 0.5 * threshold
  0.1,  иначе
}
```

### Сбор данных и метрик
- **История**: последние 1000 задач для каждого брокера
- **Частота обновления**: каждые 10 обработанных задач
- **Мониторинг**: потери, изменения θ, нормы градиентов
- **Логирование**: детальные метрики выполнения каждой задачи

## Объяснение ключевых графиков

### 1. Графики приоритета (Priority)
**Что отображают**: Распределение задач по уровням приоритета и их влияние на время выполнения.

**Интерпретация**:
- **"High" (8-10)**: Критически важные задачи, обрабатываются в первую очередь
- **"Medium" (4-7)**: Стандартные задачи с обычным приоритетом
- **"Low" (1-3)**: Задачи с низким приоритетом, могут ожидать

**Анализ**: Показывает эффективность системы приоритизации и балансировку нагрузки.

### 2. Временные графики (Dates)
**Что отображают**: Динамика ошибок предсказания брокеров за последние 30 дней.

**Компоненты**:
- **Ошибки нагрузки**: точность предсказания `p̂`
- **Ошибки времени ожидания**: точность предсказания `ŵ`
- **Тренды обучения**: как улучшается качество со временем

**Интерпретация**: Позволяет оценить стабильность системы и эффективность SPSA-оптимизации.

### 3. Успешность выполнения задач (Task Success Rate)
**Что отображают**: Процент успешно выполненных задач по типам.

**Метрики**:
- **Общая успешность**: ~95% (базовая настройка исполнителей)
- **По типам задач**: различается в зависимости от сложности
- **По исполнителям**: показывает специализацию моделей

**Факторы влияния**:
- Сложность задачи
- Загруженность исполнителя
- Релевантность задачи для конкретной модели
- Риск таймаута

### 4. Производительность агентов (Agent Performance)
**Что отображают**: Тепловые карты эффективности исполнителей для разных типов задач.

**Измерения**:
- **Строки**: типы задач (math, code, text, analysis, etc.)
- **Столбцы**: идентификаторы исполнителей (0-7)
- **Цвет**: эффективность выполнения (0.0-1.0)

**Расчет эффективности**:
```python
efficiency = (success_rate × relevance_score × (1 - timeout_risk)) / avg_execution_time
```

### 5. Графики нагрузки и консенсуса
**Что отображают**: 
- Распределение нагрузки между брокерами
- Сходимость параметров θ через консенсус
- Динамика функций потерь

**Ключевые индикаторы**:
- **Балансировка**: равномерность распределения задач
- **Сходимость**: стабилизация параметров θ
- **Качество предсказаний**: снижение функций потерь со временем

### 6. Распределение типов задач
**Что отображают**: Статистику поступающих задач по категориям.

**Анализ помогает**:
- Планировать ресурсы исполнителей
- Настраивать специализацию моделей
- Балансировать нагрузку по типам задач
- Оптимизировать граф связности брокеров

---
